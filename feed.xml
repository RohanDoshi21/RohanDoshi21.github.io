<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://rohandoshi21.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://rohandoshi21.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-05-30T07:59:58+00:00</updated><id>https://rohandoshi21.github.io/feed.xml</id><title type="html">blank</title><subtitle>Distributed Systems, Computer Networks, Cloud Computing</subtitle><entry><title type="html">Distributed MQTT Broker: A Load-Balanced Redis-Based Architecture</title><link href="https://rohandoshi21.github.io/blog/2024/Project/" rel="alternate" type="text/html" title="Distributed MQTT Broker: A Load-Balanced Redis-Based Architecture"/><published>2024-05-30T00:00:00+00:00</published><updated>2024-05-30T00:00:00+00:00</updated><id>https://rohandoshi21.github.io/blog/2024/Project</id><content type="html" xml:base="https://rohandoshi21.github.io/blog/2024/Project/"><![CDATA[<p>The Internet of Things (IoT) has revolutionized data transfer in industries through the MQTT protocol. MQTT is a lightweight messaging protocol designed for efficient communication among IoT devices. It operates on a publish-subscribe model where data producers (publishers) send messages to specific topics. Interested devices (subscribers) subscribe to these topics through an MQTT broker, facilitating communication. MQTT offers Quality of Service (QoS) levels, ensuring reliable message delivery, making it ideal for IoT with intermittent connectivity. It is valued for low overhead, scalability, and real-time communication. Traditional MQTT brokers are single-node setups, straightforward for small to moderate IoT applications. In contrast, distributed MQTT brokers are interconnected, offering scalability, redundancy, load balancing, and fault tolerance. They suit large-scale IoT deployments where reliability and performance are vital. The proposed Load-Balancer Redis-based architecture for distributed MQTT brokers overcomes the shortcomings of traditional brokers. The Load-Balancer transfers all incoming TCP packets to the brokers for processing, which ensures equal utilization of each broker node. Redis acts as a synchronization layer for the brokers where the state information is stored.</p>]]></content><author><name>Rohan Doshi</name></author><category term="Distributed Systems"/><summary type="html"><![CDATA[The Internet of Things (IoT) has revolutionized data transfer in industries through the MQTT protocol. MQTT is a lightweight messaging protocol designed for efficient communication among IoT devices. It operates on a publish-subscribe model where data producers (publishers) send messages to specific topics. Interested devices (subscribers) subscribe to these topics through an MQTT broker, facilitating communication. MQTT offers Quality of Service (QoS) levels, ensuring reliable message delivery, making it ideal for IoT with intermittent connectivity. It is valued for low overhead, scalability, and real-time communication. Traditional MQTT brokers are single-node setups, straightforward for small to moderate IoT applications. In contrast, distributed MQTT brokers are interconnected, offering scalability, redundancy, load balancing, and fault tolerance. They suit large-scale IoT deployments where reliability and performance are vital. The proposed Load-Balancer Redis-based architecture for distributed MQTT brokers overcomes the shortcomings of traditional brokers. The Load-Balancer transfers all incoming TCP packets to the brokers for processing, which ensures equal utilization of each broker node. Redis acts as a synchronization layer for the brokers where the state information is stored.]]></summary></entry><entry><title type="html">Using Firebase Remote Config as Production Environment Config in Flutter App</title><link href="https://rohandoshi21.github.io/blog/2023/using-firebase-remote-config-as-production-environment-config-in-flutter-app/" rel="alternate" type="text/html" title="Using Firebase Remote Config as Production Environment Config in Flutter App"/><published>2023-05-08T10:31:39+00:00</published><updated>2023-05-08T10:31:39+00:00</updated><id>https://rohandoshi21.github.io/blog/2023/using-firebase-remote-config-as-production-environment-config-in-flutter-app</id><content type="html" xml:base="https://rohandoshi21.github.io/blog/2023/using-firebase-remote-config-as-production-environment-config-in-flutter-app/"><![CDATA[]]></content><author><name></name></author></entry><entry><title type="html">Generate Protocol Buffer Schema from a Dart Class</title><link href="https://rohandoshi21.github.io/blog/2023/generate-protocol-buffer-schema-from-a-dart-class/" rel="alternate" type="text/html" title="Generate Protocol Buffer Schema from a Dart Class"/><published>2023-05-02T09:37:23+00:00</published><updated>2023-05-02T09:37:23+00:00</updated><id>https://rohandoshi21.github.io/blog/2023/generate-protocol-buffer-schema-from-a-dart-class</id><content type="html" xml:base="https://rohandoshi21.github.io/blog/2023/generate-protocol-buffer-schema-from-a-dart-class/"><![CDATA[]]></content><author><name></name></author></entry></feed>